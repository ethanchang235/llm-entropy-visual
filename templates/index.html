<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Entropy Visualizer</title>
    <script src='https://cdn.plot.ly/plotly-2.29.1.min.js'></script>
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-panel: #ffffff;
            --bg-input: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --border-color: #ced4da;
            --border-light: #e0e0e0;
            --accent: #007bff;
            --accent-hover: #0056b3;
            --btn-bg: #6c757d;
            --btn-hover: #5a6268;
            --shadow: rgba(0,0,0,0.08);
            --token-bg: #fff;
            --token-border: #ddd;
        }
        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-panel: #16213e;
            --bg-input: #0f3460;
            --text-primary: #e4e4e4;
            --text-secondary: #b8b8b8;
            --text-muted: #888;
            --border-color: #2a2a4a;
            --border-light: #2a2a4a;
            --accent: #4dabf7;
            --accent-hover: #74c0fc;
            --btn-bg: #3d5a80;
            --btn-hover: #4a6fa5;
            --shadow: rgba(0,0,0,0.3);
            --token-bg: #0f3460;
            --token-border: #3d5a80;
        }
        * { transition: background-color 0.2s, color 0.2s, border-color 0.2s; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            margin-top: 15px; background-color: var(--bg-primary); color: var(--text-primary); font-size: 15px;
        }
        h1 { color: var(--text-primary); text-align: center; margin-bottom: 5px; font-size: 1.8em; }
        #model-info-header { text-align: center; color: var(--text-secondary); margin-bottom: 10px; font-size: 1.1em; }
        #app-container { display: flex; flex-direction: column; width: 96%; max-width: 1300px; gap: 20px; }

        .panel {
            background-color: var(--bg-panel); padding: 20px; border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow); border: 1px solid var(--border-light);
        }

        #config-panel { display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end; justify-content: space-between; }
        .config-group { display: flex; flex-wrap: wrap; gap: 15px 20px; align-items: flex-start; }
        .config-item { display: flex; flex-direction: column; gap: 5px; min-width: 150px; }
        .config-item label, .config-item .checkbox-label { font-size: 0.9em; color: var(--text-secondary); }
        .config-item input[type="number"], .config-item input[type="range"] {
            padding: 8px 10px; font-size: 0.95em; border: 1px solid var(--border-color);
            border-radius: 4px; box-sizing: border-box; width: 100%;
            background: var(--bg-panel); color: var(--text-primary);
        }
        .config-item input[type="number"] { max-width: 100px; }
        .config-item input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        #temperature-value, #top-p-value { font-weight: bold; color: var(--accent); }
        .action-buttons button {
            padding: 8px 12px; font-size: 0.9em; border: 1px solid var(--btn-bg); border-radius: 4px;
            background-color: var(--btn-bg); color: white; cursor: pointer; transition: all 0.2s;
        }
        .action-buttons button:hover { background-color: var(--btn-hover); }
        .action-buttons button:disabled { opacity: 0.5; cursor: not-allowed; }
        .action-buttons { display: flex; gap: 10px; align-items: center; }
        #theme-toggle { font-size: 1.2em; padding: 6px 10px; }

        #main-content-wrapper { display: flex; flex-direction: column; gap: 20px; }
        #main-content { display: flex; flex-direction: column; gap: 20px; flex-grow: 1; }
        #side-panel { flex-shrink: 0; display: flex; flex-direction: column; gap: 20px; }

        @media (min-width: 992px) {
            #main-content-wrapper { flex-direction: row; }
            #main-content { flex-grow: 1; display: flex; flex-direction: column; }
            #input-analysis-section { flex: 2; }
            #output-section { flex: 3; }
            #side-panel { width: 300px; max-width: 300px; }
        }
        @media (max-width: 991px) { #side-panel { order: 3; } }

        #input-analysis-section { display: flex; flex-direction: column; gap: 15px; }
        .input-label-container { display: flex; justify-content: space-between; align-items: center; }
        .input-label-container button { font-size: 0.85em; padding: 4px 8px; }
        textarea {
            width: 100%; min-height: 150px; font-size: 1.05em; padding: 12px; box-sizing: border-box;
            border: 1px solid var(--border-color); border-radius: 4px; resize: vertical;
            background: var(--bg-panel); color: var(--text-primary);
        }

        #status-bar { display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-top: 10px; padding: 8px 0; flex-wrap: wrap; }
        #metrics-display { display: flex; flex-direction: column; gap: 4px; }
        .metric-row { display: flex; align-items: baseline; gap: 12px; flex-wrap: wrap; }
        #entropy-display { font-size: 1.3em; font-weight: bold; white-space: nowrap; transition: color 0.3s; }
        #perplexity-display { font-size: 1.1em; font-weight: 500; color: var(--text-secondary); white-space: nowrap; }
        #prob-stats { font-size: 0.9em; color: var(--text-secondary); display: flex; gap: 12px; flex-wrap: wrap; }
        #global-status-container { display: flex; align-items: center; gap: 8px; font-style: italic; color: var(--text-muted); flex-grow: 1; justify-content: flex-end; }
        .spinner { border: 3px solid var(--border-light); border-top: 3px solid var(--accent); border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #input-tokenization-display { margin-top: 10px; padding: 10px; background-color: var(--bg-input); border-radius: 4px; font-size: 0.9em; max-height: 100px; overflow-y: auto; }
        #input-tokenization-display .token { background-color: var(--token-bg); padding: 2px 5px; margin: 2px; border-radius: 3px; border: 1px solid var(--token-border); display: inline-block; font-family: monospace; }
        #input-tokenization-display .token .token-id { font-size: 0.8em; color: var(--text-muted); margin-left: 3px; }

        #output-section { display: flex; flex-direction: column; }
        .chart-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px; }
        .chart-controls .config-item { flex-direction: row; align-items: center; gap: 5px; }
        #probability-chart { width: 100%; min-height: 400px; }

        .side-panel-section h4 { margin-top: 0; margin-bottom: 10px; font-size: 1.05em; color: var(--text-primary); display: flex; justify-content: space-between; align-items: center; }
        .side-panel-section h4 button { font-size: 0.75em; padding: 3px 6px; }
        #input-history-list { list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: auto; border: 1px solid var(--border-light); border-radius: 4px; }
        #input-history-list li { padding: 6px 10px; font-size: 0.85em; cursor: pointer; border-bottom: 1px solid var(--border-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #input-history-list li:last-child { border-bottom: none; }
        #input-history-list li:hover { background-color: var(--bg-input); }
        #input-history-list li .history-entropy { float: right; color: var(--accent); font-weight: bold; margin-left: 10px; }
        #entropy-trend-chart { width: 100%; min-height: 200px; }

        .error-message { color: #dc3545; font-weight: bold; }
        .info-message { color: #17a2b8; }
        .success-message { color: #28a745; }
        button:disabled, input:disabled { cursor: not-allowed; opacity: 0.7; }

        #help-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); padding-top: 60px; }
        .help-modal-content { background-color: var(--bg-panel); color: var(--text-primary); margin: 5% auto; padding: 20px; border: 1px solid var(--border-color); width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .help-modal-content h2 { margin-top: 0; }
        .help-modal-content ul { padding-left: 20px; }
        .help-modal-content li { margin-bottom: 5px; }
        .help-modal-content kbd { background-color: var(--bg-input); border-radius: 3px; border: 1px solid var(--border-color); color: var(--text-primary); display: inline-block; font-size: .85em; font-weight: 700; line-height: 1; padding: 2px 4px; white-space: nowrap; }
        .close-help-button { color: var(--text-muted); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close-help-button:hover { color: var(--text-primary); }
        .copy-feedback { font-size: 0.8em; color: #28a745; margin-left: 5px; opacity: 0; transition: opacity 0.3s; }
        .copy-feedback.show { opacity: 1; }
    </style>
</head>
<body>
    <h1>LLM Entropy & Token Visualizer</h1>
    <div id="model-info-header">Model: <strong id="model-name-display">{{ model_display_name }}</strong></div>

    <div id="app-container">
        <div id="config-panel" class="panel">
            <div class="config-group">
                <div class="config-item">
                    <label for="top-k-input">Top K (1-50):</label>
                    <input type="number" id="top-k-input" value="15" min="1" max="50">
                </div>
                <div class="config-item">
                    <label for="temperature-input">Temperature (<span id="temperature-value">1.00</span>):</label>
                    <input type="range" id="temperature-input" min="0.01" max="2.0" step="0.01" value="1.0">
                </div>
                <div class="config-item">
                    <label for="top-p-input">Top-P (<span id="top-p-value">1.00</span>):</label>
                    <input type="range" id="top-p-input" min="0.01" max="1.0" step="0.01" value="1.0">
                </div>
            </div>
            <div class="action-buttons">
                <button id="surprise-me-button" title="Fill input with a random phrase">üé≤ Surprise Me</button>
                <button id="help-button" title="Show help information">‚ùì Help</button>
                <button id="theme-toggle" title="Toggle dark/light mode">üåô</button>
            </div>
        </div>

        <div id="main-content-wrapper">
            <div id="main-content">
                <div id="input-analysis-section" class="panel">
                    <div class="input-label-container">
                        <label for="text-input">Enter text (or leave empty to predict first token):</label>
                        <button id="clear-text-button" title="Clear input text (Esc)">Clear</button>
                    </div>
                    <textarea id="text-input" placeholder="Type here... (Ctrl+Enter or Cmd+Enter to submit)"></textarea>
                    <div id="input-tokenization-container">
                        <label>Input Tokenization:</label>
                        <div id="input-tokenization-display">No input text.</div>
                    </div>
                    <div id="status-bar">
                        <div id="metrics-display">
                            <div class="metric-row">
                                <div id="entropy-display">Entropy: -</div>
                                <div id="perplexity-display">Perplexity: -</div>
                            </div>
                            <div id="prob-stats">
                                <span id="cumulative-prob-display">Top K: -</span>
                                <span id="other-prob-display">Other: -</span>
                            </div>
                        </div>
                        <div id="global-status-container">
                            <div class="spinner" id="loading-spinner"></div>
                            <div id="global-status">Initializing...</div>
                        </div>
                    </div>
                </div>

                <div id="output-section" class="panel">
                    <div class="chart-controls">
                        <div style="display: flex; flex-wrap:wrap; gap: 15px;">
                            <div class="config-item">
                                <input type="checkbox" id="log-scale-checkbox">
                                <label for="log-scale-checkbox" class="checkbox-label">Log Scale (Prob)</label>
                            </div>
                            <div class="config-item">
                                <input type="checkbox" id="raw-tokens-checkbox">
                                <label for="raw-tokens-checkbox" class="checkbox-label">Show Raw Tokens</label>
                            </div>
                        </div>
                        <button id="copy-topk-button" class="action-buttons" title="Copy Top K tokens and probabilities">üìã Copy Top K <span id="copy-feedback" class="copy-feedback">Copied!</span></button>
                    </div>
                    <div id="probability-chart"></div>
                </div>
            </div>

            <div id="side-panel">
                <div class="panel side-panel-section">
                    <h4>
                        <span>Input History (Last <span id="max-history-count">5</span>)</span>
                        <button id="clear-history-button" title="Clear input history">Clear</button>
                    </h4>
                    <ul id="input-history-list">
                        <li><em>No history yet.</em></li>
                    </ul>
                </div>
                <div class="panel side-panel-section">
                    <h4>
                        <span>Entropy Trend (vs. Input Length)</span>
                        <button id="clear-trend-button" title="Clear entropy trend">Clear</button>
                    </h4>
                    <div id="entropy-trend-chart"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="help-modal">
        <div class="help-modal-content">
            <span class="close-help-button" id="close-help-modal-button">√ó</span>
            <h2>LLM Entropy Visualizer - Help</h2>
            <p>This tool visualizes the next token predictions of a Language Model (LLM) and calculates the Shannon entropy of its probability distribution.</p>
            <h4>Metrics</h4>
            <ul>
                <li><strong>Entropy:</strong> Shannon entropy in bits. Low = confident prediction, High = uncertain. Color-coded from green (low) to red (high).</li>
                <li><strong>Perplexity:</strong> 2<sup>entropy</sup>. Represents the "effective vocabulary size" the model is choosing from. A perplexity of 10 means the model is as uncertain as if choosing uniformly from 10 equally likely tokens.</li>
                <li><strong>Top K / Other:</strong> Probability mass in your displayed tokens vs. the rest of the vocabulary.</li>
            </ul>
            <h4>Controls</h4>
            <ul>
                <li><strong>Top K:</strong> Number of most probable tokens to display (1-50).</li>
                <li><strong>Temperature:</strong> Scales logits before softmax. Lower = sharper distribution (more confident), Higher = flatter (more random).</li>
                <li><strong>Top-P:</strong> Nucleus sampling threshold. Keeps smallest set of tokens with cumulative probability ‚â• P. Set to 1.0 to disable.</li>
            </ul>
            <h4>Keyboard Shortcuts</h4>
            <ul>
                <li><kbd>Ctrl</kbd>+<kbd>Enter</kbd> / <kbd>Cmd</kbd>+<kbd>Enter</kbd> ‚Äî Submit immediately</li>
                <li><kbd>Esc</kbd> ‚Äî Clear input</li>
                <li><kbd>D</kbd> ‚Äî Toggle dark mode (when not focused on input)</li>
            </ul>
            <h4>Tips</h4>
            <ul>
                <li>Click any bar in the chart to append that token to your input.</li>
                <li>Use log scale for highly skewed distributions.</li>
                <li>Settings persist in your browser's localStorage.</li>
            </ul>
            <p><em>Model: GPT-2 (124M parameters)</em></p>
        </div>
    </div>

    <script>
        // DOM Elements
        const textInput = document.getElementById('text-input');
        const entropyDisplay = document.getElementById('entropy-display');
        const perplexityDisplay = document.getElementById('perplexity-display');
        const cumulativeProbDisplay = document.getElementById('cumulative-prob-display');
        const otherProbDisplay = document.getElementById('other-prob-display');
        const chartDiv = document.getElementById('probability-chart');
        const globalStatusDiv = document.getElementById('global-status');
        const topKInput = document.getElementById('top-k-input');
        const loadingSpinner = document.getElementById('loading-spinner');
        const temperatureInput = document.getElementById('temperature-input');
        const temperatureValueDisplay = document.getElementById('temperature-value');
        const topPInput = document.getElementById('top-p-input');
        const topPValueDisplay = document.getElementById('top-p-value');
        const inputTokenizationDiv = document.getElementById('input-tokenization-display');
        const modelNameDisplay = document.getElementById('model-name-display');
        const surpriseMeButton = document.getElementById('surprise-me-button');
        const clearTextButton = document.getElementById('clear-text-button');
        const helpButton = document.getElementById('help-button');
        const themeToggle = document.getElementById('theme-toggle');
        const helpModal = document.getElementById('help-modal');
        const closeHelpModalButton = document.getElementById('close-help-modal-button');
        const inputHistoryList = document.getElementById('input-history-list');
        const entropyTrendChartDiv = document.getElementById('entropy-trend-chart');
        const maxHistoryCountDisplay = document.getElementById('max-history-count');
        const logScaleCheckbox = document.getElementById('log-scale-checkbox');
        const rawTokensCheckbox = document.getElementById('raw-tokens-checkbox');
        const copyTopKButton = document.getElementById('copy-topk-button');
        const copyFeedbackSpan = document.getElementById('copy-feedback');
        const clearHistoryButton = document.getElementById('clear-history-button');
        const clearTrendButton = document.getElementById('clear-trend-button');

        const allControls = [textInput, topKInput, temperatureInput, topPInput, surpriseMeButton, clearTextButton, helpButton, themeToggle, logScaleCheckbox, rawTokensCheckbox, copyTopKButton, clearHistoryButton, clearTrendButton];

        // Entropy color scale: green (low/confident) -> yellow -> red (high/uncertain)
        function getEntropyColor(entropy) {
            const maxEntropy = 12; // GPT-2 vocab ~50k, log2(50000) ‚âà 15.6, but typical max is lower
            const t = Math.min(entropy / maxEntropy, 1);
            if (t < 0.5) {
                // Green to Yellow
                const r = Math.round(255 * (t * 2));
                return `rgb(${r}, 180, 50)`;
            } else {
                // Yellow to Red
                const g = Math.round(180 * (1 - (t - 0.5) * 2));
                return `rgb(255, ${g}, 50)`;
            }
        }

        // Theme management
        function setTheme(dark) {
            document.documentElement.setAttribute('data-theme', dark ? 'dark' : 'light');
            if (themeToggle) themeToggle.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('entropyVisDarkMode', dark);
        }
        function toggleTheme() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            setTheme(!isDark);
        }

        // State
        let debounceTimer;
        let isFetchingPrediction = false;
        let currentModelDisplayName = "{{ model_display_name }}";
        let modelReady = false;
        let currentTopKData = null;

        const surprisePhrases = [
            "The quick brown fox jumps over the lazy", "Artificial intelligence is rapidly changing the", "In a hole in the ground there lived a",
            "The weather forecast for tomorrow is", "Once upon a time, in a land far away,", "To be or not to be, that is the",
            "The meaning of life is", "One small step for man, one giant leap for", "Hello world, this is a test of the", "Entropy in language models refers to"
        ];
        const MAX_HISTORY_ITEMS = 5;
        let inputHistory = []; 
        let entropyTrendData = { x: [], y: [] }; 
        if(maxHistoryCountDisplay) maxHistoryCountDisplay.textContent = MAX_HISTORY_ITEMS;

        // --- UI Update Functions ---
        function showSpinner(show) { if(loadingSpinner) loadingSpinner.style.display = show ? 'inline-block' : 'none'; }
        function setControlsDisabled(disabled) { allControls.forEach(control => { if(control) control.disabled = disabled; }); }
        function updateGlobalStatus(message, type = 'info') {
            if (globalStatusDiv) {
                globalStatusDiv.textContent = message;
                globalStatusDiv.className = ''; // Clear previous classes
                if (type === 'error') globalStatusDiv.classList.add('error-message');
                else if (type === 'success') globalStatusDiv.classList.add('success-message');
                else globalStatusDiv.classList.add('info-message');
            }
            showSpinner(type === 'info' && message.toLowerCase().includes('fetching'));
        }
        
        // --- Settings Persistence ---
        function saveSettings() {
            if (topKInput) localStorage.setItem('entropyVisTopK', topKInput.value);
            if (temperatureInput) localStorage.setItem('entropyVisTemp', temperatureInput.value);
            if (topPInput) localStorage.setItem('entropyVisTopP', topPInput.value);
            if (logScaleCheckbox) localStorage.setItem('entropyVisLogScale', logScaleCheckbox.checked);
            if (rawTokensCheckbox) localStorage.setItem('entropyVisRawTokens', rawTokensCheckbox.checked);
        }

        function loadSettings() {
            const savedTopK = localStorage.getItem('entropyVisTopK');
            if (savedTopK && topKInput) topKInput.value = parseInt(savedTopK, 10);

            const savedTemp = localStorage.getItem('entropyVisTemp');
            if (savedTemp && temperatureInput && temperatureValueDisplay) {
                temperatureInput.value = parseFloat(savedTemp);
                temperatureValueDisplay.textContent = parseFloat(savedTemp).toFixed(2);
            }

            const savedTopP = localStorage.getItem('entropyVisTopP');
            if (savedTopP && topPInput && topPValueDisplay) {
                topPInput.value = parseFloat(savedTopP);
                topPValueDisplay.textContent = parseFloat(savedTopP).toFixed(2);
            }

            const savedLogScale = localStorage.getItem('entropyVisLogScale');
            if (savedLogScale && logScaleCheckbox) logScaleCheckbox.checked = JSON.parse(savedLogScale);
            
            const savedRawTokens = localStorage.getItem('entropyVisRawTokens');
            if (savedRawTokens && rawTokensCheckbox) rawTokensCheckbox.checked = JSON.parse(savedRawTokens);
        }

        // --- History and Trend Update Functions ---
        function updateInputHistoryDisplay() {
            if (!inputHistoryList) return;
            inputHistoryList.innerHTML = '';
            if (inputHistory.length === 0) {
                inputHistoryList.innerHTML = '<li><em>No history yet.</em></li>';
            } else {
                inputHistory.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.text.length > 50 ? item.text.substring(0,47) + "..." : (item.text || "‚Äπempty‚Ä∫");
                    li.title = item.text || "‚Äπempty‚Ä∫";
                    
                    const entropySpan = document.createElement('span');
                    entropySpan.className = 'history-entropy';
                    entropySpan.textContent = item.entropy.toFixed(3);
                    li.appendChild(entropySpan);

                    li.onclick = () => {
                        textInput.value = item.text;
                        clearTimeout(debounceTimer);
                        updateVisualization(true);
                    };
                    inputHistoryList.appendChild(li);
                });
            }
        }
        function addInputToHistory(text, entropy) {
            const existingIndex = inputHistory.findIndex(item => item.text === text);
            if (existingIndex > -1) inputHistory.splice(existingIndex, 1);
            inputHistory.unshift({ text, entropy });
            if (inputHistory.length > MAX_HISTORY_ITEMS) inputHistory.pop();
            updateInputHistoryDisplay();
        }
        function clearInputHistory() {
            inputHistory = [];
            updateInputHistoryDisplay();
        }

        function updateEntropyTrendChart() {
            if (!entropyTrendChartDiv) return;
            const trace = {
                x: entropyTrendData.x, y: entropyTrendData.y, mode: 'lines+markers', type: 'scatter',
                marker: {size: 6, color: '#007bff'}, line: {color: '#007bff'}
            };
            const layout = {
                xaxis: { title: 'Input Text Length', automargin: true },
                yaxis: { title: 'Entropy (bits)', automargin: true, range: [0, Math.max(1, ...entropyTrendData.y) * 1.1 || 10] },
                margin: { l: 50, r: 20, b: 40, t: 20 },
                paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                font: {size:10}
            };
             if (entropyTrendData.x.length === 0 && entropyTrendData.y.length === 0) {
                Plotly.purge(entropyTrendChartDiv); // Clear if no data
            } else {
                Plotly.react(entropyTrendChartDiv, [trace], layout, { responsive: true, displaylogo: false });
            }
        }
        function addDataToEntropyTrend(length, entropy) {
            if (entropyTrendData.x.includes(length)) { // Update if length exists
                const idx = entropyTrendData.x.indexOf(length);
                entropyTrendData.y[idx] = entropy;
            } else { // Add new point and sort
                entropyTrendData.x.push(length);
                entropyTrendData.y.push(entropy);
                // Keep data sorted by x for a proper line plot
                let combined = entropyTrendData.x.map((val, i) => ({x: val, y: entropyTrendData.y[i]}));
                combined.sort((a, b) => a.x - b.x);
                entropyTrendData.x = combined.map(d => d.x);
                entropyTrendData.y = combined.map(d => d.y);
            }
            updateEntropyTrendChart();
        }
        function resetEntropyTrend() {
            entropyTrendData = { x: [], y: [] };
            updateEntropyTrendChart();
        }
        
        // --- Core Logic ---
        async function checkModelStatus() {
            try {
                setControlsDisabled(true);
                updateGlobalStatus('Checking model status...', 'info');
                const response = await fetch('/status');
                const data = await response.json();

                if(data.model_display_name) currentModelDisplayName = data.model_display_name;
                if(modelNameDisplay) modelNameDisplay.textContent = currentModelDisplayName;

                if (data.status === 'ready') {
                    modelReady = true;
                    updateGlobalStatus(`Model '${currentModelDisplayName}' ready on ${data.device}.`, 'success');
                    setControlsDisabled(false);
                    updateVisualization(false); // Initial prediction for empty input
                } else if (data.status === 'loading_model') {
                    updateGlobalStatus(data.message || `Model '${currentModelDisplayName}' is loading...`, 'info');
                    setTimeout(checkModelStatus, 2000); // Poll status
                } else if (data.status === 'error') {
                    updateGlobalStatus(`Error: ${data.message}`, 'error');
                    setControlsDisabled(true);
                } else {
                     updateGlobalStatus('Server initializing or unknown status...', 'info');
                    setTimeout(checkModelStatus, 2000);
                }
            } catch (error) {
                updateGlobalStatus('Failed to connect to server. Retrying...', 'error');
                setControlsDisabled(true);
                setTimeout(checkModelStatus, 5000);
            }
        }

        function displayInputTokenization(tokens, ids) {
            if (!inputTokenizationDiv) return;
            if (!tokens || tokens.length === 0) {
                inputTokenizationDiv.innerHTML = 'No input text.';
                return;
            }
            inputTokenizationDiv.innerHTML = tokens.map((token, i) => 
                `<span class="token" title="ID: ${ids[i]}">${token.replace(/ /g, ' ').replace(/\n/g, '‚Üµ')}<span class="token-id">(${ids[i]})</span></span>`
            ).join('');
        }

        async function updateVisualization(isUserInput = true) {
             if (isFetchingPrediction || !modelReady) { return; }

            const text = textInput.value;
            const topK = parseInt(topKInput.value, 10) || 15;
            const temperature = parseFloat(temperatureInput.value) || 1.0;
            const topP = parseFloat(topPInput.value) || 1.0;
            const useLogScale = logScaleCheckbox && logScaleCheckbox.checked;
            const showRawTokensInChart = rawTokensCheckbox?.checked;

            if (isUserInput) { updateGlobalStatus('Fetching predictions...', 'info'); }
            isFetchingPrediction = true;
            if (entropyDisplay) { entropyDisplay.textContent = 'Entropy: ...'; entropyDisplay.style.color = 'var(--accent)'; }
            if (perplexityDisplay) perplexityDisplay.textContent = 'Perplexity: ...';
            if (cumulativeProbDisplay) cumulativeProbDisplay.textContent = 'Top K: -';
            if (otherProbDisplay) otherProbDisplay.textContent = 'Other: -';
            currentTopKData = null;
            if (copyTopKButton) copyTopKButton.disabled = true;

            try {
                const startTime = performance.now();
                const response = await fetch('/get_entropy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, top_k: topK, temperature, top_p: topP }),
                });
                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(2);
                const data = await response.json();

                if (!response.ok) {
                    let errorMsg = `HTTP ${response.status}: ${data.error || response.statusText}`;
                    if(data.details) errorMsg += ` (${data.details})`;
                    throw new Error(errorMsg);
                }
                if (data.error_message) { throw new Error(data.error_message); }
                
                Plotly.purge(chartDiv); // Clear previous plot and events

                // Calculate and display metrics
                const entropy = data.entropy;
                const perplexity = Math.pow(2, entropy);
                const sumTopKProb = data.top_k_probabilities.reduce((sum, p) => sum + p, 0);
                const otherProb = Math.max(0, 1 - sumTopKProb);

                if (entropyDisplay) {
                    entropyDisplay.textContent = `Entropy: ${entropy.toFixed(3)} bits`;
                    entropyDisplay.style.color = getEntropyColor(entropy);
                }
                if (perplexityDisplay) {
                    perplexityDisplay.textContent = `Perplexity: ${perplexity.toFixed(1)}`;
                }
                if (cumulativeProbDisplay) {
                    cumulativeProbDisplay.textContent = `Top K: ${(sumTopKProb * 100).toFixed(1)}%`;
                }
                if (otherProbDisplay) {
                    otherProbDisplay.textContent = `Other: ${(otherProb * 100).toFixed(1)}%`;
                }
                
                displayInputTokenization(data.input_tokens_display, data.input_token_ids_display);
                
                if (isUserInput || (inputHistory.length === 0 || inputHistory[0].text !== text)) {
                    addInputToHistory(text, data.entropy);
                }
                addDataToEntropyTrend(text.length, data.entropy);

                currentTopKData = { 
                    tokens: data.top_k_tokens, // Cleaned tokens
                    raw_tokens: data.top_k_raw_tokens, // Raw tokens
                    probabilities: data.top_k_probabilities
                };
                if(copyTopKButton) copyTopKButton.disabled = false;

                const originalTokensForClick = data.top_k_tokens; // Always use cleaned tokens for click-to-append
                const chartXLabels = showRawTokensInChart 
                    ? data.top_k_raw_tokens 
                    : data.top_k_tokens.map(token => token.replace(/ /g, '\u00A0').replace(/\n/g, '‚Üµ').replace(/\t/g, '\u2192\t'));

                const plotData = [{
                    x: chartXLabels,
                    y: data.top_k_probabilities, type: 'bar', 
                    text: data.top_k_probabilities.map(p => (p * 100).toFixed(2) + '%'),
                    customdata: originalTokensForClick, // For click event, use cleaned tokens
                    textposition: 'auto', hoverinfo: 'x+text',
                    marker: { color: data.top_k_probabilities, colorscale: 'Viridis', showscale: false }
                }];
                
                const yAxisLayout = { title: 'Probability', automargin: true };
                if (useLogScale) {
                    yAxisLayout.type = 'log'; yAxisLayout.autorange = true; 
                } else {
                    yAxisLayout.type = 'linear'; yAxisLayout.range = [0, Math.max(0.001, ...data.top_k_probabilities) * 1.15];
                }

                const layout = {
                    title: `Top ${data.top_k_tokens.length} Next Token Probabilities (Temp: ${data.applied_temperature.toFixed(2)}, Top-P: ${data.applied_top_p.toFixed(2)})`,
                    xaxis: { title: 'Token', tickangle: -45, type: 'category', automargin: true, tickfont: { family: 'monospace', size: 10 } },
                    yaxis: yAxisLayout, 
                    margin: { l: 60, r: 20, b: 120, t: 60, pad: 4 },
                    paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)'
                };
                Plotly.newPlot(chartDiv, plotData, layout, { responsive: true, displaylogo: false });

                chartDiv.on('plotly_click', function(eventData){
                    if(eventData.points && eventData.points.length > 0){
                        const clickedToken = eventData.points[0].customdata; // This is the cleaned token
                        let currentText = textInput.value;
                        if (clickedToken.startsWith(' ') || currentText.endsWith(' ') || currentText.length === 0 || clickedToken === '\n' || clickedToken === ' ') {
                            textInput.value += clickedToken;
                        } else { textInput.value += ' ' + clickedToken; }
                        textInput.focus(); clearTimeout(debounceTimer); updateVisualization(false); 
                    }
                });
                updateGlobalStatus(`Ready. (Fetch time: ${duration}s)`, 'success');
            } catch (error) {
                updateGlobalStatus(`Error: ${error.message}`, 'error');
                console.error("Update visualization error:", error);
                if (entropyDisplay) { entropyDisplay.textContent = 'Entropy: Error'; entropyDisplay.style.color = '#dc3545'; }
                if (perplexityDisplay) perplexityDisplay.textContent = 'Perplexity: -';
                if (cumulativeProbDisplay) cumulativeProbDisplay.textContent = 'Top K: -';
                if (otherProbDisplay) otherProbDisplay.textContent = 'Other: -';
                Plotly.purge(chartDiv);
            } 
            finally { isFetchingPrediction = false; }
        }

        function handleTextInput() {
            if (!modelReady) return;
            clearTimeout(debounceTimer);
            updateGlobalStatus('Waiting for input...', 'info');
            if (!textInput.value) {
                displayInputTokenization([], []);
            } else if (inputTokenizationDiv) {
                inputTokenizationDiv.innerHTML = '<em>Tokenizing...</em>';
            }
            debounceTimer = setTimeout(() => updateVisualization(true), 600);
        }
        
        function handleParamChange() { 
            if (modelReady) {
                clearTimeout(debounceTimer);
                if (temperatureValueDisplay && temperatureInput) {
                    temperatureValueDisplay.textContent = parseFloat(temperatureInput.value).toFixed(2);
                }
                if (topPValueDisplay && topPInput) {
                    topPValueDisplay.textContent = parseFloat(topPInput.value).toFixed(2);
                }
                saveSettings(); // Save on any param change
                debounceTimer = setTimeout(() => updateVisualization(true), 300);
            }
        }

        // --- Event Listeners ---
        if (logScaleCheckbox) {
            logScaleCheckbox.addEventListener('change', () => {
                if (modelReady) { updateVisualization(false); saveSettings(); }
            });
        }
        if (rawTokensCheckbox) {
            rawTokensCheckbox.addEventListener('change', () => {
                if (modelReady) { updateVisualization(false); saveSettings(); }
            });
        }

        if (copyTopKButton) {
            copyTopKButton.addEventListener('click', () => {
                if (!currentTopKData || !currentTopKData.tokens || currentTopKData.tokens.length === 0) {
                    alert("No data to copy."); return;
                }
                const useRaw = rawTokensCheckbox && rawTokensCheckbox.checked;
                const tokensToCopy = useRaw ? currentTopKData.raw_tokens : currentTopKData.tokens;

                let textToCopy = "Token\tProbability\n";
                for (let i = 0; i < tokensToCopy.length; i++) {
                    textToCopy += `${tokensToCopy[i].replace(/\n/g, "\\n")}\t${currentTopKData.probabilities[i].toFixed(6)}\n`;
                }
                navigator.clipboard.writeText(textToCopy).then(() => {
                    copyFeedbackSpan?.classList.add('show');
                    setTimeout(() => copyFeedbackSpan?.classList.remove('show'), 1500);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    alert("Failed to copy text.");
                });
            });
        }

        if (surpriseMeButton) surpriseMeButton.addEventListener('click', () => {
            textInput.value = surprisePhrases[Math.floor(Math.random() * surprisePhrases.length)];
            clearTimeout(debounceTimer);
            resetEntropyTrend(); // Reset trend for new distinct input
            updateVisualization(true);
        });
        if (clearTextButton) clearTextButton.addEventListener('click', () => {
            textInput.value = '';
            resetEntropyTrend();
            clearTimeout(debounceTimer);
            updateVisualization(true);
            displayInputTokenization([],[]);
        });
        
        if (helpButton) helpButton.addEventListener('click', () => { if (helpModal) helpModal.style.display = "block"; });
        if (closeHelpModalButton) closeHelpModalButton.addEventListener('click', () => { if (helpModal) helpModal.style.display = "none"; });
        if (themeToggle) themeToggle.addEventListener('click', toggleTheme);
        window.onclick = function(event) { if (event.target === helpModal) { helpModal.style.display = "none"; } }

        // Global keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (document.activeElement === textInput) return;
            if (event.key.toLowerCase() === 'd') toggleTheme();
        });

        if (textInput) {
            textInput.addEventListener('input', handleTextInput);
            textInput.addEventListener('keydown', (event) => {
                if (!modelReady) return;
                if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault();
                    clearTimeout(debounceTimer);
                    updateVisualization(true);
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    textInput.value = '';
                    resetEntropyTrend();
                    clearTimeout(debounceTimer);
                    updateVisualization(true);
                    displayInputTokenization([], []);
                }
            });
        }

        if (topKInput) {
            topKInput.addEventListener('change', handleParamChange);
            topKInput.addEventListener('input', () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => handleParamChange(true), 700);
            });
        }
        if (temperatureInput) {
            temperatureInput.addEventListener('input', () => {
                if (temperatureValueDisplay) temperatureValueDisplay.textContent = parseFloat(temperatureInput.value).toFixed(2);
            });
            temperatureInput.addEventListener('change', handleParamChange);
        }
        if (topPInput) {
            topPInput.addEventListener('input', () => {
                if (topPValueDisplay) topPValueDisplay.textContent = parseFloat(topPInput.value).toFixed(2);
            });
            topPInput.addEventListener('change', handleParamChange);
        }

        if (clearHistoryButton) clearHistoryButton.addEventListener('click', clearInputHistory);
        if (clearTrendButton) clearTrendButton.addEventListener('click', resetEntropyTrend);

        // --- Initializations ---
        loadSettings();
        const savedDarkMode = localStorage.getItem('entropyVisDarkMode');
        setTheme(savedDarkMode === 'true');
        if (temperatureValueDisplay && temperatureInput) { temperatureValueDisplay.textContent = parseFloat(temperatureInput.value).toFixed(2); }
        if (topPValueDisplay && topPInput) { topPValueDisplay.textContent = parseFloat(topPInput.value).toFixed(2); }
        if (modelNameDisplay) { modelNameDisplay.textContent = currentModelDisplayName; }
        if (copyTopKButton) copyTopKButton.disabled = true;
        updateInputHistoryDisplay();
        updateEntropyTrendChart();
        checkModelStatus(); 
    </script>
</body>
</html>